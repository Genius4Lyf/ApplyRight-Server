const Job = require('../models/Job');
const DraftCV = require('../models/DraftCV');
const Resume = require('../models/Resume');
const Application = require('../models/Application');
const extractionService = require('../services/extraction.service');
const scoringService = require('../services/scoring.service');

const aiService = require('../services/ai.service');

const analyzeFit = async (req, res) => {
    try {
        const { jobId, resumeId, templateId } = req.body;
        const userId = req.user._id;

        // Determine Cost based on operation type
        // If jobId is present -> Full Analysis (30 credits)
        // If jobId is missing -> Create/Upload Only (15 credits)
        const ANALYSIS_COST = jobId ? 30 : 15;

        // 0. Check Credit Balance
        const user = req.user; // Assuming user is fully attached by middleware
        if (user.credits < ANALYSIS_COST) {
            return res.status(403).json({
                message: 'Insufficient credits',
                code: 'INSUFFICIENT_CREDITS',
                required: ANALYSIS_COST,
                current: user.credits
            });
        }

        // 1. Fetch Data
        const job = jobId ? await Job.findById(jobId) : null;
        const resume = await Resume.findById(resumeId);

        if (!resume) {
            return res.status(404).json({ message: 'Resume not found' });
        }

        // NEW: Handle "Create from Upload" (No Job ID)
        if (!jobId) {
            // 1. Extract Data
            const extractedData = await aiService.extractResumeProfile(resume.rawText);

            // 1b. Generate Categorized Skills using AI
            const structuredSkills = await aiService.generateStructuredSkills({
                education: extractedData.education,
                experience: extractedData.experience,
                projects: extractedData.projects,
                targetJob: null
            });

            // 2. Create Draft
            const draft = await DraftCV.create({
                userId,
                title: 'Uploaded Resume',
                source: 'upload',
                personalInfo: {
                    fullName: req.user.firstName ? `${req.user.firstName} ${req.user.lastName}` : 'Candidate',
                    email: req.user.email
                },
                professionalSummary: extractedData.summary || '',
                experience: extractedData.experience?.map(e => ({
                    title: e.role,
                    company: e.company,
                    startDate: e.startDate,
                    endDate: e.endDate,
                    // If description is array, join distinct bullets. If string, use as is.
                    description: Array.isArray(e.description) ? e.description.map(d => `• ${d}`).join('\n') : (e.description || '')
                })) || [],
                education: extractedData.education?.map(e => ({
                    degree: e.degree,
                    school: e.school,
                    field: e.field,
                    graduationDate: e.date
                })) || [],
                projects: extractedData.projects?.map(p => ({
                    title: p.title,
                    link: p.link,
                    description: Array.isArray(p.description) ? p.description.map(d => `• ${d}`).join('\n') : (p.description || '')
                })) || [],
                skills: (structuredSkills && structuredSkills.length > 0)
                    ? structuredSkills.map(s => ({ ...s, isAutoGenerated: true }))
                    : (extractedData.skills || []).map(s => ({ name: s, category: 'Uncategorized', isAutoGenerated: false })),
                isComplete: true
            });

            // 3. Deduct Credits for Upload
            user.credits -= ANALYSIS_COST;
            await user.updateOne({ credits: user.credits });

            return res.status(200).json({
                message: 'Resume parsed successfully',
                draftId: draft._id,
                fitScore: null,
                fitAnalysis: null,
                remainingCredits: user.credits // Return new balance
            });
        }

        if (!job) {
            return res.status(404).json({ message: 'Job not found' });
        }

        // 2. Perform Extraction (if not already done)
        if (!job.analysis || job.analysis.skills.length === 0) {
            const extractedJob = extractionService.extractRequirements(job.description);
            job.analysis = extractedJob;
            await job.save();
        }

        // 3. AI Analysis (replaces old manual extraction + scoringService logic if AI is active)
        // We get a smarter profile analysis from the AI
        const aiResult = await aiService.analyzeProfile(resume.rawText, job.description);

        // Update Job Metadata with AI-detected title/company
        // The AI prompt strictly extracts these from the JOB DESCRIPTION only (not the resume)
        // Scraped titles from HTML (h1/title tags) are often unreliable (e.g., page titles, link text)
        // so the AI analysis of the actual job description content is the better source of truth
        if (aiResult.detectedJobTitle) {
            job.title = aiResult.detectedJobTitle;
        }
        if (aiResult.detectedCompany && aiResult.detectedCompany !== 'Unknown Company') {
            job.company = aiResult.detectedCompany;
        }
        await job.save();

        // Map AI result to our standard format
        let fitScore = aiResult.fitScore;
        let fitAnalysis = {
            overallFeedback: aiResult.reasoning || "Analysis complete.",
            skillsGap: aiResult.missingSkills || [],

            // Use AI detailed analysis if available, otherwise fallback to simple heuristics
            experienceMatch: aiResult.experienceAnalysis?.match ?? (aiResult.experienceYears >= (job.analysis?.experience?.minYears || 0)),
            experienceFeedback: aiResult.experienceAnalysis?.feedback || (aiResult.experienceYears >= (job.analysis?.experience?.minYears || 0) ? "Meets requirements" : "Less than preferred"),

            seniorityMatch: aiResult.seniorityAnalysis?.match ?? true,
            seniorityFeedback: aiResult.seniorityAnalysis?.feedback || "Aligned with role",

            recommendation: aiResult.recommendation,
            mode: aiResult.mode // "AI" or "Standard"
        };

        // 3b. Generate Smart Action Plan
        // If AI provided an action plan, use it. Otherwise fallback to hardcoded actions.
        const actionPlan = aiResult.actionPlan || scoringService.generateActionPlan(fitAnalysis.skillsGap);

        // 3c. Generate Professional Assets (NEW: merged into analysis flow)
        // We use the same service that was used in the separate /generate endpoint
        const { optimizedCV, coverLetter } = await aiService.generateOptimizedContent(resume.rawText, job.description, {
            graduationYear: req.user.graduationYear
        });

        const { questionsToAnswer: interviewQuestions, questionsToAsk } = await aiService.generateInterviewQuestions(job.description, []);

        // 3d. Generate Categorized Skills for Application Record
        // We use the AI analysis data if possible, or parsing data
        const skillsContext = {
            education: resume.education, // Assuming resume model has parsed data? Or we rely on text?
            experience: [], // Resume Extract Service might be needed here if resume.rawText is all we have. 
            // Simplified: We pass nulls and let the AI do its best with limited context or we rely on the previous extraction?
            // BETTER APPROACH: We don't have parsed data easily available here unless we re-parse. 
            // HOWEVER, we have 'aiResult' which might have some info, but 'extractionService' data is on 'job' not 'resume'.
            // Let's assume for now we use a simpler context derived from AI or skip if empty.
            // ACTUALLY: The user pays 17 credits. We should redo extraction if needed or use what we have.
            // Let's use aiService.extractResumeProfile again? No, expensive.
            // Let's rely on `aiService.analyzeProfile` - maybe update it to return structured skills?
            // DIFFERENT STRATEGY: We call generateSkillsFromContext just with what we know.
            // Since we don't have parsed resume object here (only rawText), let's skip re-parsing for now to avoid latency.
            // We will just create an empty/basic set or rely on what's in the DraftCV if it exists?
            // Issue: `resume` model might just be { rawText }. 
            // SOLUTION: We'll skip skills generation for Analysis flow *unless* we want to enable it. 
            // The requirement says "Analysis Flow: Call generateSkillsFromContext and save...".
            // So we MUST extract. 
        };

        // Quick extraction for context
        const resumeDataForSkills = await aiService.extractResumeProfile(resume.rawText);
        const structuredSkillsApp = await aiService.generateStructuredSkills({
            education: resumeDataForSkills.education,
            experience: resumeDataForSkills.experience,
            projects: resumeDataForSkills.projects,
            targetJob: job
        });

        // 4. Save/Update Application Record
        let application = await Application.findOne({ userId, jobId, resumeId });

        if (!application) {
            application = new Application({
                userId,
                jobId,
                resumeId,
                fitScore: fitScore,
                fitAnalysis: fitAnalysis,
                actionPlan: actionPlan,
                optimizedCV: optimizedCV,
                coverLetter: coverLetter,
                interviewQuestions: interviewQuestions,
                questionsToAsk: questionsToAsk, // NEW
                templateId: templateId || 'ats-clean', // Default template
                skills: (structuredSkillsApp || []).map(s => ({ ...s, isAutoGenerated: true }))
            });
        } else {
            application.fitScore = fitScore;
            application.fitAnalysis = fitAnalysis;
            application.actionPlan = actionPlan;
            // Only update assets if they haven't been customized? 
            // For now, we overwrite on re-analysis to keep fresh with the new analysis
            application.optimizedCV = optimizedCV;
            application.coverLetter = coverLetter;
            application.interviewQuestions = interviewQuestions;
            application.questionsToAsk = questionsToAsk; // NEW
            application.skills = (structuredSkillsApp || []).map(s => ({ ...s, isAutoGenerated: true }));
            if (templateId) application.templateId = templateId;
        }

        await application.save();

        // 5. Return Result
        // 5. Deduct Credits
        user.credits -= ANALYSIS_COST;
        await user.updateOne({ credits: user.credits });

        res.status(200).json({
            fitScore: fitScore,
            fitAnalysis: fitAnalysis,
            actionPlan: actionPlan,
            optimizedCV: optimizedCV,
            coverLetter: coverLetter,
            interviewQuestions: interviewQuestions,
            questionsToAsk: questionsToAsk,
            applicationId: application._id,
            templateId: application.templateId,
            job: job, // NEW: Return updated job details
            remainingCredits: user.credits // Return new balance
        });

    } catch (error) {
        console.error('Analysis Error Details:', {
            message: error.message,
            stack: error.stack,
            body: req.body,
            user: req.user ? req.user._id : 'No User'
        });
        res.status(500).json({
            message: 'Failed to analyze fit',
            error: error.message,
            stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
        });
    }
};

const editApplication = async (req, res) => {
    try {
        const { id } = req.params;
        const userId = req.user._id;

        const application = await Application.findOne({ _id: id, userId });
        if (!application) {
            return res.status(404).json({ message: 'Application not found' });
        }

        // We use the same extraction service to parse the Optimized CV (Markdown)
        // treating it as if it were a resume text.
        const cvText = application.optimizedCV || '';
        if (!cvText) {
            return res.status(400).json({ message: 'No CV content to edit' });
        }

        // 1. Extract Structured Data from the Markdown
        const extractedData = await aiService.extractResumeProfile(cvText);

        // 1b. Generate Structured Skills (or reuse existing if we trust them? 
        // Logic: Application has structured skills now. We should prefer those!)
        // However, extractedData.skills might differ. 
        // Let's use the Application's stored skills if available, otherwise regenerate.
        let structuredSkills = [];
        if (application.skills && application.skills.length > 0) {
            structuredSkills = application.skills.map(s => ({
                name: s.name,
                category: s.category,
                isAutoGenerated: true // Assume true for simplicity or check schema
            }));
        } else {
            // Fallback: Generate from context
            structuredSkills = await aiService.generateStructuredSkills({
                education: extractedData.education,
                experience: extractedData.experience,
                projects: extractedData.projects,
                targetJob: null // Generic skills
            });
            // Map to DraftCV schema format
            structuredSkills = structuredSkills.map(s => ({ ...s, isAutoGenerated: true }));
        }

        // 2. Create Draft
        const draft = await DraftCV.create({
            userId,
            title: `Edit of ${application.jobId ? (await Job.findById(application.jobId))?.title || 'Application' : 'Application'}`,
            personalInfo: {
                fullName: req.user.firstName ? `${req.user.firstName} ${req.user.lastName}` : 'Candidate',
                email: req.user.email,
                phone: req.user.phone || '',
                linkedin: req.user.linkedinUrl || '',
                website: req.user.portfolioUrl || '',
                address: req.user.location || ''
            },
            professionalSummary: extractedData.summary || '',
            experience: extractedData.experience?.map(e => ({
                title: e.role,
                company: e.company,
                startDate: e.startDate,
                endDate: e.endDate,
                description: Array.isArray(e.description) ? e.description.map(d => `• ${d}`).join('\n') : (e.description || '')
            })) || [],
            education: extractedData.education?.map(e => ({
                degree: e.degree,
                school: e.school,
                field: e.field,
                graduationDate: e.date
            })) || [],
            projects: extractedData.projects?.map(p => ({
                title: p.title,
                link: p.link,
                description: Array.isArray(p.description) ? p.description.map(d => `• ${d}`).join('\n') : (p.description || '')
            })) || [],
            skills: structuredSkills,
            isComplete: true
        });

        return res.status(200).json({
            message: 'Draft created from Application',
            draftId: draft._id
        });

    } catch (error) {
        console.error("Edit Application Error:", error);
        res.status(500).json({ message: 'Failed to prepare edit', error: error.message });
    }
};

module.exports = {
    analyzeFit,
    editApplication
};
